name: Dependabot + Claude Review (Single Dependency)

# This workflow handles Dependabot PRs with a SINGLE dependency
# For grouped PRs (multiple dependencies), see dependabot-claude-review-grouped.yml

on:
  pull_request_target:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  # Fetch metadata about the Dependabot PR
  metadata:
    name: Fetch Dependabot Metadata
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    outputs:
      dependency-names: ${{ steps.metadata.outputs.dependency-names }}
      dependency-type: ${{ steps.metadata.outputs.dependency-type }}
      update-type: ${{ steps.metadata.outputs.update-type }}
      package-ecosystem: ${{ steps.metadata.outputs.package-ecosystem }}
      prev-version: ${{ steps.metadata.outputs.previous-version }}
      new-version: ${{ steps.metadata.outputs.new-version }}
      is-single: ${{ steps.check-single.outputs.is_single }}
      is-dependabot-pr: ${{ steps.verify-dependabot.outputs.is_dependabot_pr }}

    steps:
      - name: Verify this is a genuine Dependabot PR
        id: verify-dependabot
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          # Check that the FIRST commit in the PR is from Dependabot
          # This prevents non-Dependabot PRs from triggering the workflow

          # Get commits and validate array is not empty
          commits=$(gh pr view "$PR_URL" --json commits --jq '.commits')
          commit_count=$(echo "$commits" | jq 'length')

          if [ "$commit_count" -eq 0 ]; then
            echo "‚ùå PR has no commits - cannot verify"
            echo "is_dependabot_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          first_commit_author=$(echo "$commits" | jq -r '.[0].authors[0].login')

          echo "First commit author: $first_commit_author (total commits: $commit_count)"

          if [ "$first_commit_author" = "dependabot[bot]" ] || [ "$first_commit_author" = "app/dependabot" ]; then
            echo "is_dependabot_pr=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Verified: First commit is from Dependabot"
          else
            echo "is_dependabot_pr=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  First commit is NOT from Dependabot - skipping workflow"
          fi

      - name: Fetch Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if single dependency
        id: check-single
        run: |
          # Count dependencies (comma-separated)
          deps="${{ steps.metadata.outputs.dependency-names }}"
          count=$(echo "$deps" | tr ',' '\n' | wc -l)

          if [ "$count" -eq 1 ]; then
            echo "is_single=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Single dependency PR"
          else
            echo "is_single=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  Grouped PR detected ($count dependencies) - will be handled by dependabot-claude-review-grouped.yml"
          fi

      - name: Display metadata
        run: |
          echo "Dependency names: ${{ steps.metadata.outputs.dependency-names }}"
          echo "Dependency type: ${{ steps.metadata.outputs.dependency-type }}"
          echo "Update type: ${{ steps.metadata.outputs.update-type }}"
          echo "Package ecosystem: ${{ steps.metadata.outputs.package-ecosystem }}"
          echo "Previous version: ${{ steps.metadata.outputs.previous-version }}"
          echo "New version: ${{ steps.metadata.outputs.new-version }}"
          echo "Is single dependency: ${{ steps.check-single.outputs.is_single }}"

  # Claude review for patch updates (quick check)
  claude-review-patch:
    name: Claude Review (Patch)
    runs-on: ubuntu-latest
    needs: metadata
    if: |
      github.actor == 'dependabot[bot]' &&
      needs.metadata.outputs.is-dependabot-pr == 'true' &&
      needs.metadata.outputs.is-single == 'true' &&
      needs.metadata.outputs.update-type == 'version-update:semver-patch'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Run Claude Review
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            This is a Dependabot PATCH update for:
            - Dependencies: ${{ needs.metadata.outputs.dependency-names }}
            - Type: ${{ needs.metadata.outputs.dependency-type }}
            - Version: ${{ needs.metadata.outputs.prev-version }} ‚Üí ${{ needs.metadata.outputs.new-version }}

            Patch updates are typically bug fixes with no breaking changes. Please:

            1. Review the changes in this PR
            2. Look for changelog/release notes to understand what changed
            3. Check if there are any unexpected code changes beyond version bumps
            4. Verify this looks like a normal patch update
            5. Craft a descriptive commit message:
               - Subject: `chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}`
               - Body: Summarize the key changes from changelog (bug fixes, improvements, etc.)
               - Keep body concise (2-4 lines max)
            6. Post your review with the commit message

            **Comment format (if approved):**
            ```
            ‚úÖ **APPROVED** - Patch update looks good for auto-merge

            ## üìù Suggested Commit Message

            **Subject:**
            chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

            **Body:**
            [Your concise summary of changes from changelog]

            <!-- COMMIT_MESSAGE_START
            chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

            [Same body content]
            COMMIT_MESSAGE_END -->
            ```

            The hidden HTML comment (between `<!-- COMMIT_MESSAGE_START` and `COMMIT_MESSAGE_END -->`) will be parsed by the auto-merge workflow.

            Use `gh pr comment` with your Bash tool to leave your review.
          claude_args: '--allowed-tools "Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*)"'

  # Claude review for minor updates (moderate check + feature inspection)
  claude-review-minor:
    name: Claude Review (Minor)
    runs-on: ubuntu-latest
    needs: metadata
    if: |
      github.actor == 'dependabot[bot]' &&
      needs.metadata.outputs.is-dependabot-pr == 'true' &&
      needs.metadata.outputs.is-single == 'true' &&
      needs.metadata.outputs.update-type == 'version-update:semver-minor'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Run Claude Review
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            This is a Dependabot MINOR update for:
            - Dependencies: ${{ needs.metadata.outputs.dependency-names }}
            - Type: ${{ needs.metadata.outputs.dependency-type }}
            - Version: ${{ needs.metadata.outputs.prev-version }} ‚Üí ${{ needs.metadata.outputs.new-version }}

            Minor updates may include new features. Please:

            1. Review the changes in this PR
            2. Find and review the changelog/release notes for new features and changes
            3. Assess if any new features could benefit this codebase
            4. If beneficial features found, create a GitHub issue with:
               - Title: "Explore new features from [dependency] v${{ needs.metadata.outputs.new-version }}"
               - Description of the new features and potential use cases
               - Label: "enhancement", "dependencies"
            5. Craft a descriptive commit message:
               - Subject: `chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}`
               - Body: Summarize key changes and new features from changelog (3-5 lines max)
            6. Comment on the PR with your findings

            **Comment format (if approved):**
            ```
            ‚úÖ **APPROVED** - Minor update safe for merge. [Link to issue if created]

            ## üìù Suggested Commit Message

            **Subject:**
            chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

            **Body:**
            [Your summary of key changes and new features]

            <!-- COMMIT_MESSAGE_START
            chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

            [Same body content]
            COMMIT_MESSAGE_END -->
            ```

            If issues found: "‚ö†Ô∏è **REVIEW NEEDED** - [explain concerns]"

            Use `gh issue create` and `gh pr comment` with your Bash tool.
          claude_args: '--allowed-tools "Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh issue create:*),WebFetch,WebSearch"'

  # Claude review for major updates (thorough check + breaking change analysis)
  claude-review-major:
    name: Claude Review (Major)
    runs-on: ubuntu-latest
    needs: metadata
    if: |
      github.actor == 'dependabot[bot]' &&
      needs.metadata.outputs.is-dependabot-pr == 'true' &&
      needs.metadata.outputs.is-single == 'true' &&
      needs.metadata.outputs.update-type == 'version-update:semver-major'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install reviewdog
        uses: reviewdog/action-setup@v1
        with:
          reviewdog_version: latest

      - name: Verify reviewdog installation
        run: |
          if ! command -v reviewdog &> /dev/null; then
            echo "‚ùå reviewdog installation failed"
            echo "Claude will not be able to post inline suggestions"
            exit 1
          fi
          echo "‚úÖ reviewdog is available"
          reviewdog -version

      - name: Run Claude Review
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            This is a Dependabot MAJOR update for:
            - Dependencies: ${{ needs.metadata.outputs.dependency-names }}
            - Type: ${{ needs.metadata.outputs.dependency-type }}
            - Version: ${{ needs.metadata.outputs.prev-version }} ‚Üí ${{ needs.metadata.outputs.new-version }}
            - PR: #${{ github.event.pull_request.number }}

            Major updates may contain BREAKING CHANGES and NEW FEATURES. Please:

            1. Review the changes in this PR
            2. Find and analyze the changelog/migration guide for breaking changes AND new features
            3. Search the codebase for usage of the updated dependency
            4. Assess the impact of breaking changes on our code
            5. Identify any new features that could benefit this codebase
            6. Determine the appropriate action:

            **Breaking Change Handling:**

            **If breaking changes are SIMPLE (< 10 lines of code changes):**

            Use reviewdog to create inline GitHub suggestions:

            1. **Implement fixes locally**:
               - Use Edit/Write tools to fix the code
               - Make all necessary changes to address breaking changes

            2. **Verify fixes work**:
               ```bash
               npm test
               npm run lint
               ```

            3. **Post fixes as GitHub suggestions using reviewdog**:
               ```bash
               # Save current diff
               TMPFILE=$(mktemp)
               git diff > "${TMPFILE}"

               # Post as inline suggestions
               export REVIEWDOG_GITHUB_API_TOKEN="${{ secrets.GITHUB_TOKEN }}"
               reviewdog -f=diff -f.diff.strip=1 -reporter=github-pr-review < "${TMPFILE}"

               # Clean up changes
               git stash -u && git stash drop

               # Remove temp file
               rm -f "${TMPFILE}"
               ```

            4. **Post summary comment**:
               ```bash
               gh pr comment $PR_NUMBER --body "üîß **FIXABLE** - Simple breaking changes detected and fixed locally. Applied inline suggestions for you to review and apply."
               ```

            5. **Create tracking issue** documenting all fixes for reference

            **Benefits of this approach**:
            - You test fixes locally before suggesting
            - Reviewdog handles multi-line changes, insertions, deletions automatically
            - Creates proper "Apply suggestion" buttons
            - User maintains authorship when applying
            - PR stays open for manual application of suggestions

            **If breaking changes are COMPLEX (affect multiple files or require design decisions):**
            - Create a detailed GitHub issue with:
              - Title: "Migration required: [dependency] v${{ needs.metadata.outputs.prev-version }} ‚Üí v${{ needs.metadata.outputs.new-version }}"
              - Description: Breaking changes, affected code areas, migration steps, design considerations
              - Labels: "breaking-change", "dependencies", "help wanted"
            - Comment on PR: "‚ö†Ô∏è **MIGRATION REQUIRED** - Created issue #[issue-number] for tracking. Recommend closing this PR until migration is ready."
            - Close the PR with comment explaining why

            **If no breaking changes affect our code:**
            - Craft a descriptive commit message:
              - Subject: `chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}`
              - Body: Summarize major version changes, what's new, and confirm no breaking changes affect the codebase
            - Comment format:
              ```
              ‚úÖ **APPROVED** - Major version bump but no breaking changes affect our codebase. Safe to merge after CI passes.

              ## üìù Suggested Commit Message

              **Subject:**
              chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

              **Body:**
              [Your summary of major version changes and confirmation]

              <!-- COMMIT_MESSAGE_START
              chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

              [Same body content]
              COMMIT_MESSAGE_END -->
              ```

            **New Feature Opportunities:**

            In addition to breaking changes, if you find beneficial new features:
            - Create a separate GitHub issue for each significant new feature opportunity with:
              - Title: "Explore new features from [dependency] v${{ needs.metadata.outputs.new-version }}"
              - Description: New features, potential use cases, benefits to codebase
              - Labels: "enhancement", "dependencies"
            - Mention the feature issue(s) in your PR comment

            **Tools available**:
            - `Edit`, `Write`: Make local code changes to fix breaking changes
            - `Bash(npm test)`, `Bash(npm run lint)`: Verify fixes work
            - `Bash(reviewdog ...)`: Post changes as GitHub inline suggestions
            - `Bash(gh pr comment:*)`, `Bash(gh issue create:*)`, `Bash(gh pr close:*)`: PR/issue management
            - `WebFetch`, `WebSearch`: Find changelogs and migration guides
            - `Read`, `Grep`, `Glob`: Analyze codebase impact
          claude_args: '--allowed-tools "Edit,Write,Bash(npm *),Bash(git *),Bash(reviewdog *),Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh issue create:*),Bash(gh pr close:*),WebFetch,WebSearch,Read,Grep,Glob"'

  # Wait for all reviews and CI to complete before auto-merge decision
  auto-merge-decision:
    name: Auto-Merge Decision (Single Dependency)
    runs-on: ubuntu-latest
    needs: [metadata, claude-review-patch, claude-review-minor, claude-review-major]
    if: |
      always() &&
      github.event.pull_request.draft == false &&
      needs.metadata.outputs.is-single == 'true' &&
      (needs.claude-review-patch.result == 'success' ||
       needs.claude-review-minor.result == 'success' ||
       needs.claude-review-major.result == 'success' ||
       needs.claude-review-patch.result == 'skipped' ||
       needs.claude-review-minor.result == 'skipped' ||
       needs.claude-review-major.result == 'skipped')

    steps:
      # Checkout repository for local actions
      # IMPORTANT: This step must run BEFORE "Verify contributor trust" step
      # because the reusable action (.github/actions/verify-trusted-contributor)
      # requires the repository to be checked out to be accessible via uses: ./
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/actions
          sparse-checkout-cone-mode: false

      - name: Check if this is a fix commit
        id: check-fix-commit
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          # Get commits and validate array is not empty
          commits=$(gh pr view "$PR_URL" --json commits --jq '.commits')
          commit_count=$(echo "$commits" | jq 'length')

          if [ "$commit_count" -eq 0 ]; then
            echo "‚ùå PR has no commits - cannot check for fixes"
            echo "is_fix_commit=false" >> $GITHUB_OUTPUT
            echo "fix_author=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get latest commit message and author
          latest_commit_msg=$(echo "$commits" | jq -r '.[-1].messageHeadline')
          latest_commit_author=$(echo "$commits" | jq -r '.[-1].authors[0].login')

          echo "Latest commit: $latest_commit_msg"
          echo "Latest author: $latest_commit_author"
          echo "Total commits: $commit_count"

          # Initialize outputs
          is_fix_commit=false

          # Check if this commit is from applying suggestions
          # GitHub uses specific commit messages for applied suggestions
          if echo "$latest_commit_msg" | grep -qiE "(apply suggestions?|update.*suggestion|co-authored-by.*github-actions)"; then
            is_fix_commit=true
            echo "‚úÖ Detected fix commit (applied suggestion)"
          elif [ "$latest_commit_author" != "dependabot[bot]" ] && [ "$latest_commit_author" != "app/dependabot" ]; then
            # Non-Dependabot commit after Dependabot PR - likely a manual fix
            is_fix_commit=true
            echo "‚úÖ Detected manual fix commit from $latest_commit_author"
          else
            echo "‚ÑπÔ∏è  Not a fix commit"
          fi

          # Set outputs
          echo "is_fix_commit=$is_fix_commit" >> $GITHUB_OUTPUT
          echo "fix_author=$latest_commit_author" >> $GITHUB_OUTPUT

      # Verify contributor trust using reusable action
      - name: Verify contributor trust
        if: steps.check-fix-commit.outputs.is_fix_commit == 'true'
        id: verify-contributor
        uses: ./.github/actions/verify-trusted-contributor
        with:
          username: ${{ steps.check-fix-commit.outputs.fix_author }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
      - name: Check Claude approval
        id: check-approval
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          IS_FIX_COMMIT: ${{ steps.check-fix-commit.outputs.is_fix_commit }}
          IS_TRUSTED: ${{ steps.verify-contributor.outputs.is-trusted }}
          FIX_AUTHOR: ${{ steps.check-fix-commit.outputs.fix_author }}
          TRUST_REASON: ${{ steps.verify-contributor.outputs.reason }}
        run: |
          # Get the latest comment from claude[bot]
          latest_comment=$(gh pr view "$PR_URL" --json comments --jq '.comments | map(select(.author.login == "claude[bot]")) | last | .body')

          echo "Latest Claude comment:"
          echo "$latest_comment"

          # Check if Claude approved for auto-merge
          if echo "$latest_comment" | grep -q "‚úÖ \*\*APPROVED\*\*"; then
            echo "approved=true" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
            echo "‚úÖ Claude approved the changes"
          elif [ "$IS_FIX_COMMIT" = "true" ] && echo "$latest_comment" | grep -q "üîß \*\*FIXABLE\*\*"; then
            # Special case: This is a fix commit for a FIXABLE PR
            # Check contributor trust before proceeding
            if [ "$IS_TRUSTED" = "true" ]; then
              echo "approved=true" >> $GITHUB_OUTPUT
              echo "needs_verification=true" >> $GITHUB_OUTPUT
              echo "‚úÖ Fix commit from trusted contributor - needs final verification"
            else
              echo "approved=false" >> $GITHUB_OUTPUT
              echo "needs_verification=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è  Fix commit from untrusted contributor ($FIX_AUTHOR) - blocking auto-merge"
              echo "Reason: $TRUST_REASON"
              gh pr comment "$PR_URL" --body "‚ö†Ô∏è **SECURITY BLOCK** - Fix commit from @$FIX_AUTHOR who is not a trusted contributor.

              **Reason:** $TRUST_REASON

              A repository maintainer must manually review and approve this PR."
            fi
          else
            echo "approved=false" >> $GITHUB_OUTPUT
            echo "needs_verification=false" >> $GITHUB_OUTPUT
            if echo "$latest_comment" | grep -q "üîß \*\*FIXABLE\*\*"; then
              echo "‚ö†Ô∏è  Claude identified fixable breaking changes - manual fixes required"
            elif echo "$latest_comment" | grep -q "‚ö†Ô∏è \*\*MIGRATION REQUIRED\*\*"; then
              echo "‚ö†Ô∏è  Claude identified complex migration needed"
            else
              echo "‚ö†Ô∏è  Claude did not approve for auto-merge"
            fi
          fi

      - name: Checkout repository for final verification
        if: steps.check-approval.outputs.needs_verification == 'true'
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Final Claude verification before merge
        if: steps.check-approval.outputs.needs_verification == 'true'
        id: final-verification
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            FINAL VERIFICATION before auto-merge of Dependabot PR #${{ github.event.pull_request.number }}

            **Context**:
            - This Dependabot PR was marked as üîß **FIXABLE** with breaking changes
            - A fix commit was applied by a trusted contributor: @${{ steps.check-fix-commit.outputs.fix_author }}
            - The workflow is requesting your final verification before enabling auto-merge

            **Your task**:
            1. Review the fix commit(s) that were applied after the initial Dependabot update
            2. Verify the fixes correctly address the breaking changes you identified
            3. Check for any introduced bugs, security issues, or unintended changes
            4. Ensure code quality and project conventions are maintained
            5. Confirm everything looks safe to merge
            6. **Craft an updated commit message** that includes:
               - The dependency update information
               - Summary of fixes that were applied (1-3 lines)

            **Tools available**:
            - `gh pr diff` - View all changes in the PR
            - `gh pr view` - View PR details and commit history
            - `Read`, `Grep`, `Glob` - Analyze codebase if needed

            **Response format**:
            Post a comment with one of these markers:

            **If verified and safe to merge:**
            ```
            ‚úÖ **VERIFIED** - Fixes look good, safe to auto-merge after CI passes

            [Brief summary of what was verified]

            ## üìù Updated Commit Message

            **Subject:**
            chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

            **Body:**
            [Summary of the dependency update changes]

            Applied fixes:
            - [1-3 line summary of fixes that were applied]

            <!-- COMMIT_MESSAGE_START
            chore(deps)(${{ needs.metadata.outputs.package-ecosystem }}): bump ${{ needs.metadata.outputs.dependency-names }} from ${{ needs.metadata.outputs.prev-version }} to ${{ needs.metadata.outputs.new-version }}

            [Same body content as above]
            COMMIT_MESSAGE_END -->
            ```

            **If issues found:**
            ```
            ‚ö†Ô∏è **ISSUES FOUND** - [Describe problems found - will block auto-merge]
            ```

            Use `gh pr comment` to post your verification result.
          claude_args: '--allowed-tools "Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Read,Grep,Glob"'

      - name: Check final verification result
        if: steps.check-approval.outputs.needs_verification == 'true'
        id: check-verification
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          # Get the latest comment from claude[bot] (should be the verification)
          latest_comment=$(gh pr view "$PR_URL" --json comments --jq '.comments | map(select(.author.login == "claude[bot]")) | last | .body')

          echo "Latest Claude verification comment:"
          echo "$latest_comment"

          if echo "$latest_comment" | grep -q "‚úÖ \*\*VERIFIED\*\*"; then
            echo "verified=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Claude verified the fixes - proceeding with auto-merge"
          else
            echo "verified=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Claude found issues or did not verify - blocking auto-merge"
          fi

      # Evaluate whether this PR should be auto-merged
      # This step consolidates all the complex conditionals into a single boolean output
      # to improve readability and maintainability of subsequent steps
      - name: Evaluate auto-merge eligibility
        id: evaluate-auto-merge
        run: |
          # Check if Claude approved/verified
          claude_ok="false"
          if [ "${{ steps.check-approval.outputs.approved }}" = "true" ]; then
            if [ "${{ steps.check-approval.outputs.needs_verification }}" = "false" ]; then
              claude_ok="true"
            elif [ "${{ steps.check-verification.outputs.verified }}" = "true" ]; then
              claude_ok="true"
            fi
          fi

          echo "claude_ok=$claude_ok" >> $GITHUB_OUTPUT

          # Check if this update type qualifies for auto-merge
          should_auto_merge="false"
          if [ "$claude_ok" = "true" ]; then
            # GitHub Actions (not major)
            if [ "${{ needs.metadata.outputs.package-ecosystem }}" = "github_actions" ] && \
               [ "${{ needs.metadata.outputs.update-type }}" != "version-update:semver-major" ]; then
              should_auto_merge="true"
            # npm dev dependencies (patch or minor)
            elif [ "${{ needs.metadata.outputs.package-ecosystem }}" = "npm" ] && \
                 [ "${{ needs.metadata.outputs.dependency-type }}" = "direct:development" ] && \
                 ( [ "${{ needs.metadata.outputs.update-type }}" = "version-update:semver-patch" ] || \
                   [ "${{ needs.metadata.outputs.update-type }}" = "version-update:semver-minor" ] ); then
              should_auto_merge="true"
            # npm prod dependencies (patch only)
            elif [ "${{ needs.metadata.outputs.package-ecosystem }}" = "npm" ] && \
                 [ "${{ needs.metadata.outputs.dependency-type }}" = "direct:production" ] && \
                 [ "${{ needs.metadata.outputs.update-type }}" = "version-update:semver-patch" ]; then
              should_auto_merge="true"
            fi
          fi

          echo "should_auto_merge=$should_auto_merge" >> $GITHUB_OUTPUT

          echo "üìä Auto-merge evaluation:"
          echo "  Claude approved/verified: $claude_ok"
          echo "  Should auto-merge: $should_auto_merge"

      - name: Auto-approve if Claude approved or verified
        if: steps.evaluate-auto-merge.outputs.claude_ok == 'true'
        run: |
          gh pr review --approve "$PR_URL"
          if [ "${{ steps.check-approval.outputs.needs_verification }}" = "true" ]; then
            gh pr comment "$PR_URL" --body "‚úÖ **AUTO-APPROVED** - Applied fixes verified by Claude. Auto-merge will proceed after CI passes."
          fi
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract commit message from Claude's comment
        if: steps.evaluate-auto-merge.outputs.should_auto_merge == 'true'
        id: extract-commit-msg
        uses: ./.github/actions/extract-claude-commit-message
        with:
          pr-url: ${{ github.event.pull_request.html_url }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable auto-merge for approved updates
        if: steps.evaluate-auto-merge.outputs.should_auto_merge == 'true'
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SUBJECT: ${{ steps.extract-commit-msg.outputs.commit_subject }}
          COMMIT_BODY: ${{ steps.extract-commit-msg.outputs.commit_body }}
          # Fallback values if no commit message found
          ECOSYSTEM: ${{ needs.metadata.outputs.package-ecosystem }}
          DEPENDENCY_NAMES: ${{ needs.metadata.outputs.dependency-names }}
          PREV_VERSION: ${{ needs.metadata.outputs.prev-version }}
          NEW_VERSION: ${{ needs.metadata.outputs.new-version }}
        run: |
          # Use Claude's commit message if available, otherwise fallback to default format
          if [ -n "$COMMIT_SUBJECT" ]; then
            echo "Using Claude-suggested commit message"
            commit_subject="$COMMIT_SUBJECT"
            commit_body="$COMMIT_BODY"
          else
            echo "Using fallback commit message format"
            commit_subject="chore(deps)($ECOSYSTEM): bump $DEPENDENCY_NAMES from $PREV_VERSION to $NEW_VERSION (#$PR_NUMBER)"
            commit_body="Automated dependency update."
          fi

          echo "Commit subject: $commit_subject"
          echo "Commit body: $commit_body"

          # Validate commit subject is not empty
          if [ -z "$commit_subject" ]; then
            echo "‚ùå Commit subject is empty - cannot enable auto-merge"
            exit 1
          fi

          # Enable auto-merge with commit message
          if [ -n "$commit_body" ]; then
            gh pr merge --auto --squash --subject "$commit_subject" --body "$commit_body" "$PR_URL"
          else
            gh pr merge --auto --squash --subject "$commit_subject" "$PR_URL"
          fi

          gh pr edit "$PR_URL" --add-label "dependabot-auto-merge"

      - name: Label for manual merge
        if: |
          steps.check-approval.outputs.approved == 'true' &&
          (steps.check-approval.outputs.needs_verification == 'false' ||
           steps.check-verification.outputs.verified == 'true') &&
          (
            (needs.metadata.outputs.package-ecosystem == 'npm' &&
             needs.metadata.outputs.dependency-type == 'direct:production' &&
             needs.metadata.outputs.update-type != 'version-update:semver-patch') ||
            (needs.metadata.outputs.package-ecosystem == 'github_actions' &&
             needs.metadata.outputs.update-type == 'version-update:semver-major')
          )
        run: |
          gh pr edit "$PR_URL" --add-label "dependabot-approved" --add-label "ready-to-merge"
          gh pr comment "$PR_URL" --body "‚úÖ **Claude approved** - This PR is ready for manual merge after CI passes."
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
