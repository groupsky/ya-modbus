name: Dependabot + Claude Review (Grouped)

# This workflow handles Dependabot PRs that contain MULTIPLE dependencies (groups)
# For single-dependency PRs, see dependabot-claude-review.yml

on:
  pull_request_target:
    types:
      - opened
      - synchronize
      - reopened
      - ready_for_review

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  # Detect if this is a grouped PR
  detect-group:
    name: Detect Grouped PR
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    outputs:
      is-grouped: ${{ steps.check.outputs.is_grouped }}
      dependency-count: ${{ steps.check.outputs.dependency_count }}
      is-dependabot-pr: ${{ steps.verify-dependabot.outputs.is_dependabot_pr }}

    steps:
      # Verify this is a genuine Dependabot PR by checking first commit
      - name: Verify this is a genuine Dependabot PR
        id: verify-dependabot
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          # Get commits and validate array is not empty
          commits=$(gh pr view "$PR_URL" --json commits --jq '.commits')
          commit_count=$(echo "$commits" | jq 'length')

          if [ "$commit_count" -eq 0 ]; then
            echo "‚ùå PR has no commits - cannot verify"
            echo "is_dependabot_pr=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Get first commit author from the PR
          first_commit_author=$(echo "$commits" | jq -r '.[0].authors[0].login')

          echo "‚ÑπÔ∏è  First commit author: $first_commit_author (total commits: $commit_count)"

          # Verify first commit is from Dependabot
          if [ "$first_commit_author" = "dependabot[bot]" ] || [ "$first_commit_author" = "app/dependabot" ]; then
            echo "is_dependabot_pr=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Verified: First commit is from Dependabot"
          else
            echo "is_dependabot_pr=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Security: First commit is NOT from Dependabot (author: $first_commit_author)"
            echo "‚ö†Ô∏è  Skipping workflow for security reasons"
            exit 0
          fi

      - name: Check if grouped PR
        id: check
        if: steps.verify-dependabot.outputs.is_dependabot_pr == 'true'
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine if grouped
        id: analyze
        if: steps.verify-dependabot.outputs.is_dependabot_pr == 'true'
        run: |
          # Count dependencies (comma-separated)
          deps="${{ steps.check.outputs.dependency-names }}"
          count=$(echo "$deps" | tr ',' '\n' | wc -l)

          echo "dependency_count=$count" >> $GITHUB_OUTPUT

          if [ "$count" -gt 1 ]; then
            echo "is_grouped=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Grouped PR detected: $count dependencies"
          else
            echo "is_grouped=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  Single dependency PR (will be handled by main workflow)"
          fi

  # Claude review for GROUPED Dependabot PRs
  claude-review-grouped:
    name: Claude Review (Grouped Dependencies)
    runs-on: ubuntu-latest
    needs: detect-group
    if: |
      github.actor == 'dependabot[bot]' &&
      needs.detect-group.outputs.is-dependabot-pr == 'true' &&
      needs.detect-group.outputs.is-grouped == 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install reviewdog
        uses: reviewdog/action-setup@v1
        with:
          reviewdog_version: latest

      - name: Verify reviewdog installation
        run: |
          if ! command -v reviewdog &> /dev/null; then
            echo "‚ùå reviewdog installation failed"
            echo "‚ö†Ô∏è  Claude will not be able to post inline suggestions"
            exit 1
          fi
          echo "‚úÖ reviewdog is available"
          reviewdog -version

      - name: Fetch metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run Claude Review
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            This is a GROUPED Dependabot PR updating MULTIPLE dependencies:

            **Dependencies**: ${{ steps.metadata.outputs.dependency-names }}
            **Highest severity**: ${{ steps.metadata.outputs.update-type }}
            **Package ecosystem**: ${{ steps.metadata.outputs.package-ecosystem }}
            **PR**: #${{ github.event.pull_request.number }}

            ‚ö†Ô∏è IMPORTANT: This PR contains ${{ needs.detect-group.outputs.dependency-count }} dependencies.
            You MUST analyze EACH dependency individually.

            ## Your Task

            1. **Parse the PR changes** to identify each dependency and its version change
               - Use `gh pr diff` to see package.json/package-lock.json changes
               - Extract: package name, old version, new version, update type for EACH

            2. **Categorize each dependency** by update type:
               - Patch updates (bug fixes)
               - Minor updates (new features)
               - Major updates (breaking changes)

            3. **Analyze each category**:

               **For PATCH updates**:
               - Quick validation that changes look reasonable
               - Note any unexpected changes

               **For MINOR updates**:
               - Review changelogs for new features
               - Identify beneficial features for this codebase
               - Create GitHub issues for significant opportunities

               **For MAJOR updates**:
               - Analyze breaking changes in detail
               - Search codebase for affected usage
               - For SIMPLE fixes (< 10 lines): Implement fixes locally and use reviewdog to create suggestions
               - For COMPLEX fixes: Create migration issues with detailed steps

               **Simple fixes workflow**:
               1. Use Edit/Write to implement fixes locally
               2. Run `npm test` and `npm run lint` to verify
               3. Use reviewdog to post changes as GitHub suggestions:
                  ```bash
                  TMPFILE=$(mktemp)
                  git diff > "${TMPFILE}"
                  export REVIEWDOG_GITHUB_API_TOKEN="${{ secrets.GITHUB_TOKEN }}"
                  reviewdog -f=diff -f.diff.strip=1 -reporter=github-pr-review < "${TMPFILE}"
                  git stash -u && git stash drop
                  rm -f "${TMPFILE}"
                  ```

            4. **Provide comprehensive summary** with structure:
               ```
               ## Grouped Dependency Review

               ### Summary
               - X patch updates (low risk)
               - Y minor updates (new features available)
               - Z major updates (breaking changes)

               ### Patch Updates ‚úÖ
               - package-a: v1.0.0 ‚Üí v1.0.1 (bug fixes)
               - package-b: v2.3.4 ‚Üí v2.3.5 (security fix)

               ### Minor Updates ‚¨ÜÔ∏è
               - package-c: v3.0.0 ‚Üí v3.1.0
                 - New feature: XYZ (created issue #123)

               ### Major Updates ‚ö†Ô∏è
               - package-d: v4.0.0 ‚Üí v5.0.0
                 - Breaking change: ABC
                 - Impact: [analysis]
                 - Action: [fix in PR / create migration issue / approve if no impact]

               ### Overall Recommendation
               [APPROVED / NEEDS FIXES / MIGRATION REQUIRED]
               ```

            5. **Take appropriate actions**:
               - Create enhancement issues for beneficial minor features
               - Create migration issues for complex major updates
               - Implement fixes in PR if major breaking changes are simple
               - Approve if all updates are safe

            6. **Craft commit message** (if approved):
               - Count dependencies: ${{ needs.detect-group.outputs.dependency-count }}
               - If ‚â§3: List all packages in subject
               - If >3: Use count summary in subject
               - Body: Summarize key changes across all dependencies (3-6 lines)
                 - Group similar changes (e.g., "Bug fixes in X, Y, Z")
                 - Highlight important changes
                 - Keep concise but informative

            7. **Final comment** with your summary, recommendation, and commit message

            **Comment format (if approved):**
            ```
            [Your grouped dependency review summary]

            ## üìù Suggested Commit Message

            **Subject:**
            chore(deps)(${{ steps.metadata.outputs.package-ecosystem }}): bump [packages or count]

            **Body:**
            [Your summary of key changes across all dependencies]

            <!-- COMMIT_MESSAGE_START
            chore(deps)(${{ steps.metadata.outputs.package-ecosystem }}): bump [packages or count]

            [Same body content]
            COMMIT_MESSAGE_END -->
            ```

            ## Tools Available

            - `Edit`, `Write` - Make local code changes to fix breaking changes
            - `Bash(npm test)`, `Bash(npm run lint)` - Verify fixes work
            - `Bash(reviewdog ...)` - Post changes as GitHub inline suggestions
            - `Bash(gh pr diff:*)`, `Bash(gh pr view:*)` - View PR details
            - `Bash(gh pr comment:*)`, `Bash(gh issue create:*)` - PR/issue management
            - `WebFetch`, `WebSearch` - Find changelogs
            - `Read`, `Grep`, `Glob` - Analyze codebase impact

            ## Approval Markers

            Use one of these in your final comment:
            - ‚úÖ **APPROVED** - All updates safe to merge after CI passes (include commit message)
            - üîß **FIXABLE** - Simple breaking changes found, implemented locally and posted as suggestions
            - ‚ö†Ô∏è **REVIEW NEEDED** - Complex issues require human review
            - ‚ö†Ô∏è **MIGRATION REQUIRED** - Created migration issues, manual work needed

          claude_args: '--allowed-tools "Edit,Write,Bash(npm *),Bash(git *),Bash(reviewdog *),Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh issue create:*),WebFetch,WebSearch,Read,Grep,Glob"'

  # Auto-merge decision for grouped PRs
  auto-merge-grouped:
    name: Auto-Merge Decision (Grouped)
    runs-on: ubuntu-latest
    needs: [detect-group, claude-review-grouped]
    if: |
      always() &&
      github.actor == 'dependabot[bot]' &&
      needs.detect-group.outputs.is-grouped == 'true' &&
      needs.claude-review-grouped.result == 'success'

    steps:
      - name: Fetch metadata
        id: metadata
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # Checkout repository for local actions
      # IMPORTANT: Must run before extract-claude-approval step
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          sparse-checkout: |
            .github/actions
          sparse-checkout-cone-mode: false

      - name: Check Claude approval
        id: check-approval
        uses: ./.github/actions/extract-claude-approval
        with:
          pr-url: ${{ github.event.pull_request.html_url }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # Check if there are fix commits that need final verification
      - name: Check for fix commits
        id: check-fix-commit
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          REPO: ${{ github.repository }}
        run: |
          # Get all commits in the PR
          commits=$(gh pr view "$PR_URL" --json commits --jq '.commits')
          commit_count=$(echo "$commits" | jq 'length')

          echo "‚ÑπÔ∏è  Total commits in PR: $commit_count"

          if [ "$commit_count" -gt 1 ]; then
            # Get the latest commit info
            latest_commit_author=$(echo "$commits" | jq -r '.[-1].authors[0].login')
            latest_commit_message=$(echo "$commits" | jq -r '.[-1].messageHeadline')

            echo "‚ÑπÔ∏è  Latest commit author: $latest_commit_author"
            echo "‚ÑπÔ∏è  Latest commit message: $latest_commit_message"

            # Check if this is a fix commit (not from Dependabot)
            if [ "$latest_commit_author" != "dependabot[bot]" ] && [ "$latest_commit_author" != "app/dependabot" ]; then
              # Detect if this is an "Apply suggestions" commit
              is_apply_suggestions="false"
              if echo "$latest_commit_message" | grep -qi "apply.*suggestion"; then
                is_apply_suggestions="true"
                echo "üìù Detected 'Apply suggestions' commit from @$latest_commit_author"
              fi

              echo "fix_author=$latest_commit_author" >> $GITHUB_OUTPUT
              echo "has_fix_commits=true" >> $GITHUB_OUTPUT
              echo "is_apply_suggestions=$is_apply_suggestions" >> $GITHUB_OUTPUT
              echo "‚úÖ Fix commits detected from @$latest_commit_author"
            else
              echo "has_fix_commits=false" >> $GITHUB_OUTPUT
              echo "is_apply_suggestions=false" >> $GITHUB_OUTPUT
              echo "‚ÑπÔ∏è  No fix commits (all from Dependabot)"
            fi
          else
            echo "has_fix_commits=false" >> $GITHUB_OUTPUT
            echo "is_apply_suggestions=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  Only one commit (Dependabot's initial commit)"
          fi

      # Verify contributor trust if fix commits detected
      - name: Verify contributor trust
        if: steps.check-fix-commit.outputs.has_fix_commits == 'true'
        id: verify-contributor
        uses: ./.github/actions/verify-trusted-contributor
        with:
          username: ${{ steps.check-fix-commit.outputs.fix_author }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # Block if untrusted contributor
      - name: Block untrusted contributor
        if: |
          steps.check-fix-commit.outputs.has_fix_commits == 'true' &&
          steps.verify-contributor.outputs.is-trusted != 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          AUTHOR: ${{ steps.check-fix-commit.outputs.fix_author }}
          REASON: ${{ steps.verify-contributor.outputs.reason }}
        run: |
          echo "‚ùå Security block: Untrusted contributor"
          echo "‚ÑπÔ∏è  Author: $AUTHOR"
          echo "‚ÑπÔ∏è  Reason: $REASON"

          gh pr comment "$PR_URL" --body "‚ö†Ô∏è **SECURITY BLOCK** - Fix commit from @$AUTHOR who is not a trusted contributor.

          **Reason:** $REASON

          A repository maintainer must manually review and approve this PR."

          exit 1

      # Determine if final verification is needed
      - name: Check if verification needed
        if: |
          steps.check-fix-commit.outputs.has_fix_commits != 'true' ||
          steps.verify-contributor.outputs.is-trusted == 'true'
        id: check-verification-needed
        run: |
          # Final verification is needed if:
          # 1. Fix commits exist from a trusted contributor
          # 2. The contributor passed the trust check earlier

          has_fixes="${{ steps.check-fix-commit.outputs.has_fix_commits }}"

          if [ "$has_fixes" = "true" ]; then
            echo "needs_verification=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Final verification needed - fix commits detected from trusted contributor"
          else
            echo "needs_verification=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No verification needed - no fix commits"
          fi

      # Setup for final verification
      - name: Checkout repository
        if: steps.check-verification-needed.outputs.needs_verification == 'true'
        uses: actions/checkout@v6
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Setup Node.js
        if: steps.check-verification-needed.outputs.needs_verification == 'true'
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        if: steps.check-verification-needed.outputs.needs_verification == 'true'
        run: npm ci

      # Final Claude verification for fix commits
      - name: Final Claude verification before merge
        if: steps.check-verification-needed.outputs.needs_verification == 'true'
        id: final-verification
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          prompt: |
            FINAL VERIFICATION before auto-merge of grouped Dependabot PR #${{ github.event.pull_request.number }}

            **Context**:
            - This grouped PR updates ${{ needs.detect-group.outputs.dependency-count }} dependencies
            - Fix commits were applied by: @${{ steps.check-fix-commit.outputs.fix_author }}
            - Applied via: ${{ steps.check-fix-commit.outputs.is_apply_suggestions == 'true' && 'GitHub suggestion (Apply suggestion button)' || 'Manual commit' }}
            - The workflow is requesting your final verification before enabling auto-merge

            **Your task**:
            1. Review the fix commit(s) that were applied after the initial Dependabot update
            2. Verify the fixes correctly address any breaking changes
            3. Check for any introduced bugs, security issues, or unintended changes
            4. Ensure code quality and project conventions are maintained
            5. Confirm everything looks safe to merge
            6. **Craft an updated commit message** that includes:
               - Summary of the grouped dependency updates
               - Summary of fixes that were applied (1-3 lines)

            **Tools available**:
            - `gh pr diff` - View all changes in the PR
            - `gh pr view` - View PR details and commit history
            - `Read`, `Grep`, `Glob` - Analyze codebase if needed

            **Response format**:
            Post a comment with one of these markers:

            **If verified and safe to merge:**
            ```
            ‚úÖ **VERIFIED** - Fixes look good, safe to auto-merge after CI passes

            [Brief summary of what was verified]

            ## üìù Updated Commit Message

            **Subject:**
            chore(deps)(${{ steps.metadata.outputs.package-ecosystem }}): bump ${{ needs.detect-group.outputs.dependency-count }} dependencies

            **Body:**
            [Summary of the grouped dependency updates]

            Applied fixes:
            - [1-3 line summary of fixes that were applied]

            <!-- COMMIT_MESSAGE_START
            chore(deps)(${{ steps.metadata.outputs.package-ecosystem }}): bump ${{ needs.detect-group.outputs.dependency-count }} dependencies

            [Same body content as above]
            COMMIT_MESSAGE_END -->
            ```

            **If issues found:**
            ```
            ‚ö†Ô∏è **ISSUES FOUND** - [Describe problems found - will block auto-merge]
            ```

            Use `gh pr comment` to post your verification result.
          claude_args: '--allowed-tools "Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Read,Grep,Glob"'

      - name: Wait for and check final verification result
        if: steps.check-verification-needed.outputs.needs_verification == 'true'
        id: check-final-verification
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          # Poll for Claude's verification comment (check every 2s for up to 60s)
          echo "‚ÑπÔ∏è  Waiting for Claude's verification comment..."
          max_attempts=30  # 60 seconds total
          attempt=0
          start_time=$(date +%s)
          found_comment=false

          while [ $attempt -lt $max_attempts ]; do
            # Check if latest Claude comment has verification markers
            latest_comment=$(gh pr view "$PR_URL" --json comments --jq '.comments | map(select(.author.login == "claude[bot]")) | last | .body' 2>/dev/null || echo "")

            if echo "$latest_comment" | grep -qE "(‚úÖ \*\*VERIFIED\*\*|‚ö†Ô∏è \*\*ISSUES FOUND\*\*)"; then
              end_time=$(date +%s)
              duration=$((end_time - start_time))
              echo "‚úÖ Found Claude's verification comment after $duration seconds"
              found_comment=true
              break
            fi

            attempt=$((attempt + 1))
            if [ $attempt -lt $max_attempts ]; then
              echo "‚ÑπÔ∏è  Attempt $attempt/$max_attempts - waiting 2s for comment..."
              sleep 2
            fi
          done

          # Check if we timed out
          if [ "$found_comment" = "false" ]; then
            end_time=$(date +%s)
            duration=$((end_time - start_time))
            echo "‚ö†Ô∏è  Timeout: Claude's verification comment not found after $duration seconds"
            echo "verified=false" >> $GITHUB_OUTPUT
            gh pr comment "$PR_URL" --body "‚ö†Ô∏è **Auto-merge blocked** - Timeout waiting for Claude's final verification (${duration}s). Please check the workflow logs."
            exit 1
          fi

      - name: Extract final verification decision
        if: steps.check-verification-needed.outputs.needs_verification == 'true'
        id: extract-final-verification
        uses: ./.github/actions/extract-claude-approval
        with:
          pr-url: ${{ github.event.pull_request.html_url }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Block if verification failed
        if: |
          steps.check-verification-needed.outputs.needs_verification == 'true' &&
          steps.extract-final-verification.outputs.decision != 'VERIFIED'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_URL: ${{ github.event.pull_request.html_url }}
        run: |
          echo "‚ö†Ô∏è  Claude found issues or did not verify (decision: ${{ steps.extract-final-verification.outputs.decision }})"
          gh pr comment "$PR_URL" --body "‚ö†Ô∏è **Auto-merge blocked** - Claude's final verification did not pass. Please review the concerns raised above."
          exit 1

      # Evaluate whether this PR should be auto-merged
      # This step consolidates all the complex conditionals into a single boolean output
      # to improve readability and maintainability of subsequent steps
      - name: Evaluate auto-merge eligibility
        id: evaluate-auto-merge
        run: |
          # Check if Claude approved/verified
          claude_ok="false"
          if [ "${{ steps.check-approval.outputs.approved }}" = "true" ]; then
            claude_ok="true"
          elif [ "${{ steps.check-verification-needed.outputs.needs_verification }}" = "true" ] && \
               [ "${{ steps.extract-final-verification.outputs.decision }}" = "VERIFIED" ]; then
            claude_ok="true"
          fi

          echo "claude_ok=$claude_ok" >> $GITHUB_OUTPUT

          # For grouped PRs, only auto-merge dev dependencies
          should_auto_merge="false"
          if [ "$claude_ok" = "true" ] && \
             [ "${{ steps.metadata.outputs.dependency-type }}" = "direct:development" ]; then
            should_auto_merge="true"
          fi

          echo "should_auto_merge=$should_auto_merge" >> $GITHUB_OUTPUT

          echo "üìä Auto-merge evaluation:"
          echo "  ‚Ä¢ Claude approved/verified: $claude_ok"
          echo "  ‚Ä¢ Dependency type: ${{ steps.metadata.outputs.dependency-type }}"
          echo "  ‚Ä¢ Should auto-merge: $should_auto_merge"

      - name: Auto-approve if Claude approved
        if: steps.evaluate-auto-merge.outputs.claude_ok == 'true'
        run: gh pr review --approve "$PR_URL"
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract commit message from Claude's comment
        if: steps.evaluate-auto-merge.outputs.should_auto_merge == 'true'
        id: extract-commit-msg
        uses: ./.github/actions/extract-claude-commit-message
        with:
          pr-url: ${{ github.event.pull_request.html_url }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Enable auto-merge for dev dependencies
        if: steps.evaluate-auto-merge.outputs.should_auto_merge == 'true'
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SUBJECT: ${{ steps.extract-commit-msg.outputs.commit_subject }}
          COMMIT_BODY: ${{ steps.extract-commit-msg.outputs.commit_body }}
          # Fallback values
          ECOSYSTEM: ${{ steps.metadata.outputs.package-ecosystem }}
          DEPENDENCY_NAMES: ${{ steps.metadata.outputs.dependency-names }}
        run: |
          # Use Claude's commit message if available, otherwise fallback
          if [ -n "$COMMIT_SUBJECT" ]; then
            echo "‚ÑπÔ∏è  Using Claude-suggested commit message"
            commit_subject="$COMMIT_SUBJECT"
            commit_body="$COMMIT_BODY"
          else
            echo "‚ÑπÔ∏è  Using fallback commit message format"
            # Count dependencies
            dep_count=$(echo "$DEPENDENCY_NAMES" | tr ',' '\n' | wc -l)

            # Construct commit message
            if [ "$dep_count" -le 3 ]; then
              # Few dependencies - list them all
              deps=$(echo "$DEPENDENCY_NAMES" | tr ',' ', ')
              commit_subject="chore(deps)($ECOSYSTEM): bump $deps (#$PR_NUMBER)"
            else
              # Many dependencies - use summary
              commit_subject="chore(deps)($ECOSYSTEM): bump $dep_count dependencies (#$PR_NUMBER)"
            fi
            commit_body="Grouped dependency updates."
          fi

          echo "‚ÑπÔ∏è  Commit subject: $commit_subject"

          # Validate commit subject is not empty
          if [ -z "$commit_subject" ]; then
            echo "‚ùå Commit subject is empty - cannot enable auto-merge"
            exit 1
          fi

          # Enable auto-merge with commit message
          if [ -n "$commit_body" ]; then
            gh pr merge --auto --squash --subject "$commit_subject" --body "$commit_body" "$PR_URL"
          else
            gh pr merge --auto --squash --subject "$commit_subject" "$PR_URL"
          fi

          gh pr edit "$PR_URL" --add-label "dependabot-auto-merge"

      - name: Label for manual merge (prod deps or major updates)
        if: |
          (steps.check-approval.outputs.approved == 'true' ||
           (steps.check-verification-needed.outputs.needs_verification == 'true' &&
            steps.check-final-verification.outputs.verified == 'true')) &&
          (steps.metadata.outputs.dependency-type == 'direct:production' ||
           steps.metadata.outputs.update-type == 'version-update:semver-major')
        run: |
          gh pr edit "$PR_URL" --add-label "dependabot-approved" --add-label "ready-to-merge"
          gh pr comment "$PR_URL" --body "‚úÖ **Claude approved** - Grouped PR ready for manual merge after CI passes."
        env:
          PR_URL: ${{ github.event.pull_request.html_url }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
