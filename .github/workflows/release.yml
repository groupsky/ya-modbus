name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      dist-tag:
        description: 'NPM dist-tag (leave empty to auto-generate from branch name, or specify: beta, next, etc.)'
        required: false
        default: ''
      dry-run:
        description: 'Dry run (validate without publishing)'
        required: false
        type: boolean
        default: false

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write # For creating tags and pushing commits
  issues: write # For creating GitHub releases
  pull-requests: write # For release notes
  id-token: write # For OIDC token (attestations)
  attestations: write # For build provenance
  security-events: write # For uploading SARIF reports

jobs:
  release:
    name: Release Packages
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: npm
    # Don't run on version bump commits to avoid infinite loop
    # Note: For push events on main, branch protection should require CI to pass before merge
    # For manual triggers, tests run inline below as a safety check
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' &&
       !startsWith(github.event.head_commit.message, 'chore(release):') &&
       github.event.head_commit.author.username != 'github-actions[bot]')

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          # Fetch all history and tags for lerna to detect changes
          fetch-depth: 0
          # Use a token that can trigger workflows
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check workflow permissions
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "Checking permissions for manual workflow trigger..."

          # Get user's permission level
          PERMISSION=$(gh api \
            repos/${{ github.repository }}/collaborators/${{ github.actor }}/permission \
            --jq '.permission')

          echo "User: ${{ github.actor }}"
          echo "Permission: $PERMISSION"

          # Allow only maintain and admin permissions (not write, read, or triage)
          if [ "$PERMISSION" != "maintain" ] && [ "$PERMISSION" != "admin" ]; then
            echo "âŒ Insufficient permissions to trigger manual pre-releases"
            echo "   Required: maintain or admin access"
            echo "   Current: $PERMISSION"
            exit 1
          fi

          echo "âœ… Permission check passed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js from .nvmrc
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Detect release type
        id: release-type
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

          # Check dry-run mode
          DRY_RUN="${{ github.event.inputs.dry-run }}"
          if [ "$DRY_RUN" == "true" ]; then
            echo "is_dry_run=true" >> $GITHUB_OUTPUT
            echo "ðŸ” DRY RUN MODE - No publishing will occur"
          else
            echo "is_dry_run=false" >> $GITHUB_OUTPUT
          fi

          # Determine dist-tag (empty input means auto-generate from branch)
          DIST_TAG_INPUT="${{ github.event.inputs.dist-tag }}"

          # Determine if this is a pre-release
          if [ "$BRANCH" != "main" ] || [ -n "$DIST_TAG_INPUT" ]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT

            # Determine dist-tag
            if [ -n "$DIST_TAG_INPUT" ]; then
              DIST_TAG="$DIST_TAG_INPUT"

              # Validate dist-tag format
              if ! echo "$DIST_TAG" | grep -qE '^[a-zA-Z0-9][a-zA-Z0-9-]*$'; then
                echo "âŒ Invalid dist-tag format: $DIST_TAG"
                echo "   Must start with alphanumeric and contain only alphanumeric and hyphens"
                exit 1
              fi

              # Check for reserved tags
              if [ "$DIST_TAG" == "latest" ] || [ "$DIST_TAG" == "next" ]; then
                echo "âŒ Reserved dist-tag: $DIST_TAG"
                echo "   Use empty value to trigger production release on main branch"
                exit 1
              fi

              # Check length (npm allows up to 214 chars, but keep it reasonable)
              if [ ${#DIST_TAG} -gt 50 ]; then
                echo "âŒ Dist-tag too long: ${#DIST_TAG} chars (max 50)"
                exit 1
              fi
            else
              # Auto-generate dist-tag from branch name
              DIST_TAG=$(echo "$BRANCH" | sed 's/[^a-zA-Z0-9-]/-/g' | sed 's/^-*//' | sed 's/-*$//')

              # Ensure dist-tag is not empty after sanitization
              if [ -z "$DIST_TAG" ]; then
                echo "âŒ Cannot generate valid dist-tag from branch name: $BRANCH"
                exit 1
              fi
            fi
            echo "dist_tag=$DIST_TAG" >> $GITHUB_OUTPUT

            # Determine preid for versioning (remove trailing numeric suffix if present)
            PREID=$(echo "$DIST_TAG" | sed 's/-[0-9]*$//')
            echo "preid=$PREID" >> $GITHUB_OUTPUT

            echo "ðŸ“¦ Pre-release mode: dist-tag=$DIST_TAG, preid=$PREID"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "dist_tag=latest" >> $GITHUB_OUTPUT
            echo "ðŸ“¦ Production release mode"
          fi

      - name: Install dependencies
        run: npm ci

      - name: Build packages
        run: npm run build

      - name: Run tests
        run: npm run test:ci

      - name: Version packages (production)
        if: steps.release-type.outputs.is_prerelease == 'false'
        id: version-production
        run: |
          # Capture current tags before versioning
          TAGS_BEFORE=$(git tag | wc -l)

          # Run lerna version (exits 0 even if no changes)
          npx lerna version --yes --no-private --sync-workspace-lock || EXIT_CODE=$?

          # Check if any new tags were created
          TAGS_AFTER=$(git tag | wc -l)
          TAGS_CREATED=$((TAGS_AFTER - TAGS_BEFORE))

          if [ $TAGS_CREATED -eq 0 ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No packages to release - no changes detected"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "âœ… Created $TAGS_CREATED version tag(s)"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Version packages (pre-release)
        if: steps.release-type.outputs.is_prerelease == 'true'
        id: version-prerelease
        run: |
          npx lerna version prerelease \
            --preid ${{ steps.release-type.outputs.preid }} \
            --no-git-tag-version \
            --no-push \
            --yes \
            --no-private \
            --sync-workspace-lock

      - name: Check for version conflicts (pre-release)
        if: steps.release-type.outputs.is_prerelease == 'true' && steps.release-type.outputs.is_dry_run == 'false'
        run: |
          echo "Checking for version conflicts on npm..."
          CONFLICT_FOUND=false

          # Get list of packages and their versions from package.json files
          for pkg_json in packages/*/package.json; do
            if [ -f "$pkg_json" ]; then
              PKG_NAME=$(jq -r '.name' "$pkg_json")
              PKG_VERSION=$(jq -r '.version' "$pkg_json")
              PKG_PRIVATE=$(jq -r '.private // false' "$pkg_json")

              # Skip private packages
              if [ "$PKG_PRIVATE" == "true" ]; then
                continue
              fi

              echo "Checking $PKG_NAME@$PKG_VERSION..."

              # Check if this version exists on npm
              if npm view "$PKG_NAME@$PKG_VERSION" version 2>/dev/null; then
                echo "  âŒ Version $PKG_VERSION already exists on npm!"
                CONFLICT_FOUND=true
              else
                echo "  âœ… Version $PKG_VERSION is available"
              fi
            fi
          done

          if [ "$CONFLICT_FOUND" == "true" ]; then
            echo ""
            echo "âŒ ERROR: Version conflict detected!"
            echo "One or more package versions already exist on npm."
            echo ""
            echo "This can happen when:"
            echo "  - Multiple pre-releases are triggered simultaneously"
            echo "  - A previous release succeeded but workflow failed afterward"
            echo ""
            echo "Please wait a moment and try again to get the next version number."
            exit 1
          fi

          echo "âœ… No version conflicts detected"

      - name: Publish to npm (production)
        if: |
          steps.release-type.outputs.is_prerelease == 'false' &&
          steps.release-type.outputs.is_dry_run == 'false' &&
          steps.version-production.outputs.has_changes == 'true'
        run: npx lerna publish from-git --yes --no-private --provenance

      - name: No changes detected
        if: |
          steps.release-type.outputs.is_prerelease == 'false' &&
          steps.version-production.outputs.has_changes == 'false'
        run: |
          echo "â„¹ï¸ No packages have changes that warrant a release."
          echo ""
          echo "This can happen when:"
          echo "  - Only ignored files changed (tests, docs, config)"
          echo "  - Commits don't match conventional commit format"
          echo "  - Recent release already published the changes"
          echo ""
          echo "See lerna.json ignoreChanges for patterns that skip releases."

      - name: Publish to npm (pre-release)
        if: steps.release-type.outputs.is_prerelease == 'true' && steps.release-type.outputs.is_dry_run == 'false'
        run: |
          npx lerna publish from-package \
            --dist-tag ${{ steps.release-type.outputs.dist_tag }} \
            --no-git-reset \
            --yes \
            --no-private \
            --provenance

      - name: Find PR for this branch
        if: steps.release-type.outputs.is_prerelease == 'true' && steps.release-type.outputs.is_dry_run == 'false'
        id: find-pr
        run: |
          BRANCH="${{ steps.release-type.outputs.branch }}"
          PR_NUMBER=$(gh pr list --head "$BRANCH" --state open --json number --jq '.[0].number')
          if [ -n "$PR_NUMBER" ]; then
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "âœ… Found PR #$PR_NUMBER for branch $BRANCH"
          else
            echo "pr_number=" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No open PR found for branch $BRANCH"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Comment on PR with pre-release info
        if: steps.release-type.outputs.is_prerelease == 'true' && steps.release-type.outputs.is_dry_run == 'false' && steps.find-pr.outputs.pr_number != ''
        run: |
          gh pr comment ${{ steps.find-pr.outputs.pr_number }} --body "## ðŸ“¦ Pre-release Published

          **Dist-tag**: \`${{ steps.release-type.outputs.dist_tag }}\`

          Install this pre-release version:
          \`\`\`bash
          npm install @ya-modbus/cli@${{ steps.release-type.outputs.dist_tag }}
          \`\`\`

          > The dist-tag will be automatically removed when this PR is closed or merged.

          <!-- ya-modbus-prerelease: ${{ steps.release-type.outputs.dist_tag }} -->"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Dry run summary
        if: steps.release-type.outputs.is_dry_run == 'true'
        run: |
          echo "ðŸ” DRY RUN COMPLETE - No packages were published"
          echo ""
          echo "Release configuration:"
          echo "  Branch: ${{ steps.release-type.outputs.branch }}"
          echo "  Pre-release: ${{ steps.release-type.outputs.is_prerelease }}"
          echo "  Dist-tag: ${{ steps.release-type.outputs.dist_tag }}"
          echo ""
          echo "To publish, re-run without dry-run option."

      - name: Extract version for Docker tags
        id: extract-version
        if: steps.release-type.outputs.is_dry_run == 'false'
        run: |
          # Get version from mqtt-bridge package (main package for Docker)
          VERSION=$(jq -r '.version' packages/mqtt-bridge/package.json)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ MQTT Bridge version: $VERSION"

      - name: Summary
        if: always()
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.release-type.outputs.is_dry_run }}" == "true" ]; then
            echo "**ðŸ” DRY RUN MODE** - No packages were published" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- Branch: ${{ steps.release-type.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
          echo "- Pre-release: ${{ steps.release-type.outputs.is_prerelease }}" >> $GITHUB_STEP_SUMMARY
          echo "- Dist-tag: ${{ steps.release-type.outputs.dist_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Dry run: ${{ steps.release-type.outputs.is_dry_run }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.release-type.outputs.is_prerelease }}" == "true" ] && [ "${{ steps.release-type.outputs.is_dry_run }}" == "false" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Installation" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "npm install @ya-modbus/cli@${{ steps.release-type.outputs.dist_tag }}" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

    outputs:
      is_prerelease: ${{ steps.release-type.outputs.is_prerelease }}
      is_dry_run: ${{ steps.release-type.outputs.is_dry_run }}
      dist_tag: ${{ steps.release-type.outputs.dist_tag }}
      version: ${{ steps.extract-version.outputs.version }}
      has_changes: ${{ steps.version-production.outputs.has_changes }}

  docker-publish:
    name: Build and Publish Docker Images
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: release
    # Only run if packages were published (not dry-run, not no-changes)
    if: |
      needs.release.outputs.is_dry_run == 'false' &&
      (needs.release.outputs.is_prerelease == 'true' || needs.release.outputs.has_changes == 'true')

    permissions:
      contents: read
      packages: write # For GHCR
      id-token: write # For attestations
      attestations: write # For build provenance

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Get build timestamp
        id: build-date
        run: echo "date=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Docker tags
        id: docker-tags
        run: |
          VERSION="${{ needs.release.outputs.version }}"
          IS_PRERELEASE="${{ needs.release.outputs.is_prerelease }}"
          DIST_TAG="${{ needs.release.outputs.dist_tag }}"

          # Docker Hub repository
          DOCKERHUB_REPO="groupsky/ya-modbus"
          # GHCR repository
          GHCR_REPO="ghcr.io/${{ github.repository }}"

          if [ "$IS_PRERELEASE" == "true" ]; then
            # Pre-release tags: version and dist-tag
            TAGS_BASE="$DOCKERHUB_REPO:$VERSION,$GHCR_REPO:$VERSION"
            TAGS_BASE="$TAGS_BASE,$DOCKERHUB_REPO:$DIST_TAG,$GHCR_REPO:$DIST_TAG"
            TAGS_COMPLETE="$DOCKERHUB_REPO:$VERSION-complete,$GHCR_REPO:$VERSION-complete"
            TAGS_COMPLETE="$TAGS_COMPLETE,$DOCKERHUB_REPO:$DIST_TAG-complete,$GHCR_REPO:$DIST_TAG-complete"
            echo "ðŸ“¦ Pre-release Docker tags: $VERSION, $DIST_TAG"
          else
            # Production tags: version, latest
            TAGS_BASE="$DOCKERHUB_REPO:$VERSION,$GHCR_REPO:$VERSION"
            TAGS_COMPLETE="$DOCKERHUB_REPO:$VERSION-complete,$GHCR_REPO:$VERSION-complete"
            TAGS_COMPLETE="$TAGS_COMPLETE,$DOCKERHUB_REPO:latest,$GHCR_REPO:latest"
            echo "ðŸ“¦ Production Docker tags: $VERSION, latest"
          fi

          echo "tags_base=$TAGS_BASE" >> $GITHUB_OUTPUT
          echo "tags_complete=$TAGS_COMPLETE" >> $GITHUB_OUTPUT

      - name: Build and push base variant
        uses: docker/build-push-action@v6
        id: build-base
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          build-args: |
            VARIANT=base
          push: true
          tags: ${{ steps.docker-tags.outputs.tags_base }}
          cache-from: type=gha,scope=base
          cache-to: type=gha,mode=max,scope=base
          provenance: mode=max
          sbom: true
          labels: |
            org.opencontainers.image.title=ya-modbus
            org.opencontainers.image.description=Production-ready Modbus to MQTT bridge (base variant)
            org.opencontainers.image.version=${{ needs.release.outputs.version }}
            org.opencontainers.image.vendor=ya-modbus
            org.opencontainers.image.licenses=GPL-3.0-or-later
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.build-date.outputs.date }}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.documentation=https://github.com/${{ github.repository }}#readme
            org.opencontainers.image.authors=ya-modbus contributors
            org.opencontainers.image.base.name=docker.io/library/node:24-alpine

      - name: Build and push complete variant
        uses: docker/build-push-action@v6
        id: build-complete
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          build-args: |
            VARIANT=complete
          push: true
          tags: ${{ steps.docker-tags.outputs.tags_complete }}
          cache-from: type=gha,scope=complete
          cache-to: type=gha,mode=max,scope=complete
          provenance: mode=max
          sbom: true
          labels: |
            org.opencontainers.image.title=ya-modbus
            org.opencontainers.image.description=Production-ready Modbus to MQTT bridge (complete variant with all drivers)
            org.opencontainers.image.version=${{ needs.release.outputs.version }}
            org.opencontainers.image.vendor=ya-modbus
            org.opencontainers.image.licenses=GPL-3.0-or-later
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.build-date.outputs.date }}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.documentation=https://github.com/${{ github.repository }}#readme
            org.opencontainers.image.authors=ya-modbus contributors
            org.opencontainers.image.base.name=docker.io/library/node:24-alpine

      - name: Docker publish summary
        run: |
          echo "## ðŸ³ Docker Images Published" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Base Variant" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "docker pull groupsky/ya-modbus:${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ghcr.io/${{ github.repository }}:${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Complete Variant (Recommended)" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "docker pull groupsky/ya-modbus:${{ needs.release.outputs.version }}-complete" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ghcr.io/${{ github.repository }}:${{ needs.release.outputs.version }}-complete" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.release.outputs.is_prerelease }}" == "false" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Latest Tag" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "docker pull groupsky/ya-modbus:latest" >> $GITHUB_STEP_SUMMARY
            echo "docker pull ghcr.io/${{ github.repository }}:latest" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

  docker-scan:
    name: Security Scan Docker Images
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [release, docker-publish]
    if: |
      needs.release.outputs.is_dry_run == 'false' &&
      (needs.release.outputs.is_prerelease == 'true' || needs.release.outputs.has_changes == 'true')

    permissions:
      contents: read
      security-events: write # For uploading SARIF results

    strategy:
      fail-fast: false
      matrix:
        variant: [base, complete]

    steps:
      - name: Determine image tag
        id: image-tag
        run: |
          VERSION="${{ needs.release.outputs.version }}"
          VARIANT="${{ matrix.variant }}"

          if [ "$VARIANT" == "complete" ]; then
            TAG="$VERSION-complete"
          else
            TAG="$VERSION"
          fi

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "ðŸ” Scanning image: groupsky/ya-modbus:$TAG"

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: groupsky/ya-modbus:${{ steps.image-tag.outputs.tag }}
          format: 'sarif'
          output: 'trivy-results-${{ matrix.variant }}.sarif'
          severity: 'CRITICAL,HIGH'
          vuln-type: 'os,library'
          scanners: 'vuln,secret,config'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results-${{ matrix.variant }}.sarif'
          category: 'docker-${{ matrix.variant }}'

      - name: Run Trivy vulnerability scanner (table output)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: groupsky/ya-modbus:${{ steps.image-tag.outputs.tag }}
          format: 'table'
          severity: 'CRITICAL,HIGH,MEDIUM'
          vuln-type: 'os,library'
          scanners: 'vuln,secret,config'

      - name: Security scan summary
        if: always()
        run: |
          echo "## ðŸ”’ Security Scan: ${{ matrix.variant }} variant" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Image: \`groupsky/ya-modbus:${{ steps.image-tag.outputs.tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Scan results uploaded to Security tab" >> $GITHUB_STEP_SUMMARY

  github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [release, docker-publish]
    # Only create releases for production (not pre-release, not dry-run, not no-changes)
    if: |
      needs.release.outputs.is_dry_run == 'false' &&
      needs.release.outputs.is_prerelease == 'false' &&
      needs.release.outputs.has_changes == 'true'

    permissions:
      contents: write # For creating releases

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0 # Fetch all history for changelog generation

      - name: Generate changelog
        id: changelog
        run: |
          VERSION="${{ needs.release.outputs.version }}"

          # Find the previous release tag
          PREVIOUS_TAG=$(git tag --sort=-version:refname | grep -v "$VERSION" | head -n 1)

          if [ -z "$PREVIOUS_TAG" ]; then
            echo "No previous tag found, using initial commit"
            PREVIOUS_TAG=$(git rev-list --max-parents=0 HEAD)
          fi

          echo "Generating changelog from $PREVIOUS_TAG to v$VERSION"

          # Generate changelog using conventional commits (save directly to temp files)
          git log $PREVIOUS_TAG..HEAD --pretty=format:"- %s (%h)" --no-merges > changelog-all.txt

          # Group by type
          grep "^- feat" changelog-all.txt > changelog-features.txt || true
          grep "^- fix" changelog-all.txt > changelog-fixes.txt || true
          grep "^- perf" changelog-all.txt > changelog-perf.txt || true
          git log $PREVIOUS_TAG..HEAD --pretty=format:"%B" --no-merges | grep "BREAKING CHANGE:" > changelog-breaking.txt || true

          # Build formatted changelog directly to file
          > changelog.md

          if [ -s changelog-breaking.txt ]; then
            echo "## âš ï¸ Breaking Changes" >> changelog.md
            echo "" >> changelog.md
            cat changelog-breaking.txt >> changelog.md
            echo "" >> changelog.md
            echo "" >> changelog.md
          fi

          if [ -s changelog-features.txt ]; then
            echo "## âœ¨ Features" >> changelog.md
            echo "" >> changelog.md
            cat changelog-features.txt >> changelog.md
            echo "" >> changelog.md
            echo "" >> changelog.md
          fi

          if [ -s changelog-fixes.txt ]; then
            echo "## ðŸ› Bug Fixes" >> changelog.md
            echo "" >> changelog.md
            cat changelog-fixes.txt >> changelog.md
            echo "" >> changelog.md
            echo "" >> changelog.md
          fi

          if [ -s changelog-perf.txt ]; then
            echo "## âš¡ Performance Improvements" >> changelog.md
            echo "" >> changelog.md
            cat changelog-perf.txt >> changelog.md
            echo "" >> changelog.md
            echo "" >> changelog.md
          fi

          # Clean up temp files
          rm -f changelog-all.txt changelog-features.txt changelog-fixes.txt changelog-perf.txt changelog-breaking.txt

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.release.outputs.version }}"

          # Create release notes
          cat > release-notes.md <<'EOF'
          ## Docker Images

          Multi-platform images (linux/amd64, linux/arm64) are available on Docker Hub and GitHub Container Registry.

          ### Quick Start

          **Complete variant** (recommended - includes all built-in drivers):
          ```bash
          docker pull groupsky/ya-modbus:latest
          # or
          docker pull ghcr.io/${{ github.repository }}:latest
          ```

          **Base variant** (core bridge only, install drivers separately):
          ```bash
          docker pull groupsky/ya-modbus:${{ needs.release.outputs.version }}
          # or
          docker pull ghcr.io/${{ github.repository }}:${{ needs.release.outputs.version }}
          ```

          ### Security

          All images include:
          - ðŸ”’ SBOM (Software Bill of Materials)
          - âœ… Build provenance attestation
          - ðŸ›¡ï¸ Vulnerability scanning (see Security tab)

          Verify image attestations:
          ```bash
          docker buildx imagetools inspect groupsky/ya-modbus:${{ needs.release.outputs.version }} --format "{{ json .Provenance }}"
          ```

          ### NPM Packages

          Install packages via npm:
          ```bash
          npm install -g ya-modbus@${{ needs.release.outputs.version }}
          ```

          ## Changelog

          EOF

          # Append generated changelog
          cat changelog.md >> release-notes.md

          # Create the release
          gh release create "v$VERSION" \
            --title "v$VERSION" \
            --notes-file release-notes.md \
            --verify-tag

      - name: Release summary
        run: |
          echo "## ðŸ“¦ GitHub Release Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Version: v${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "View: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
